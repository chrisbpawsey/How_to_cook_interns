% begin the document
\begin{Document}

\Title{Internship Report for Ranganai Mapondera and Ozlem Erkilic}
\Subtitle{Getexample: Reducing Barriers to Entry on Shared HPC Resources}

\author{\IEEEauthorblockN{Ranganai Mapondera}
\IEEEauthorblockA{Pawsey Supercomputing Centre\\
Curtin University\\
Perth, Australia\\
Email:ranganai.mapondera@student.curtin.edu.au }
\and
\IEEEauthorblockN{Ozlem Erkilic}
\IEEEauthorblockA{Pawsey Supercomputing Centre\\
Curtin University\\
Perth, Australia\\
Email:ozlem.erkilic@student.curtin.edu.au}
\\


\Section{Abstract}
\begin{abstract}

The best way to understand a concept is by going through and working out examples to easily aqcuire knowledge that is intended to pass which helps to complete tasks given in various resources, constraints and goals.
A lot of expert users browse through the internet to find these examples but there are always so many of them which are not specifically for what they need. 
This brings the challenge of having to modify the example to suit their requirements on a particular computing resource (HPC). 
The modified example mostly do not work and it is hard to tell what the problem is. 
The user will not be able to tell if the example is even correct or if the code is broken or if the example is correct and the modifications are correct but some adjustments are needed. 
This paper provides solutions to this problem through the use of a simple resource "getexample". 
The "getexample" is a simple utility that helps users with specific working examples to complete their tasks on a specific mentioned HPC system.




\end{abstract}
\\
\Section{Introduction}
\begin{Introduction}

Even though there are many sample codes on search engines for programming purposes, it is usually very rare that these codes work at the first try 
on different high performance computing systems without modifying them. This is mainly due to each advanced computing system being built up differently
from each other to perform specific tasks for the needs of the users.Therefore, this  becomes very challanging for the users, especially the novices to
change the example codes to display a working task on HPC resources as there are many differences between each resources with many constraints. The most
common differences between these HPC systems are as follow:

1) Different operating systems 
2) Different program environments
3) Different compiler commands
4) Different compiler flags and wrappers for varying compiler options
5) Different module systems and paths
6) Different module naming conventions
7) Different versions of libraries
8) Different scheduling policies





\end{Introduction}
\
\
\Section{Overview of getexample}

The main aim of the "getexample" is to provide easy access to the examples.It is expected to be founded on the following terms:

1) Easy to use for everyone including beginners
2) Practical examples which can be modified or updated by other users for their own work
3) The example should be clearly and completely detailed with steps to help users to fathom and apply it

\Section{Scope}
\begin{scope}

This shows the expected results from this Internship at Pawsey Supercomputing Center
\
\



\end{scope}
\
\Section{Creating Examples}

\Subsection{Magnus}

This is described as a Cray X40 supercomputer that consists of many nodes that are connected by a high speed network. The cray supercomputer consists of intel Xeon E5-2690 v3(Haswell) as its only processor across all compute nodes. For the compute nodes, each one of them has 2 processors and each of these 2 processors has 12 cores.
Magnus is specified to have 24 cores per node and in total these sum up to 35,712 cores across the 1488 nodes. Each of these nodes has a memory of 64GB. The maximum login nodes of magnus are 2.
During this summer internship, the focus was to provide simplified getexamples which we developed and each othe directories described below consists of mainly the source code, the slurm file and the Readme . The source code details the script with the example code taken from online sources or developed to be the job script. The jobscript produces the executable file after being compiled. The slurm file is where a batch script is submitted. It runs the executable from the jobscript. The executable file will be used by the compiler. In the slurm, we have slurm directives where we choose the number of nodes or ntasks. We also specify the compiler before the executable. The Readme file is where the executable file is run. The slurm is given because it contains the compiler. The results from running the executable are submitted to Scratch which deletes the files after some time. A new group has been created which stores all the files from scratch and in the script the results are deleted from scratch and only viewed in group. Compute nodes are attached to scratch and are capable of moving back and forth.
Fortan and C code were used for most of the examples to illustrate the differences. Some wrappers were implemented as well for these compilers which are ftn,mpif90 and cc. When using these, it is important to invoke the actual programming environment being used PrgEnv-cray, PrgEnv-gnu or PrgEnv-intel.The relevant paths are organized via the module system.



\Subsubsection{MPI Jobs}

For MPI , we used fortran and c compilers. We ran the jobs on cray, gnu and intel.


\Subsubsection{OMP Jobs}



\Subsubsection{Helloworld Jobs}



\Subsubsection{CUDA Jobs}



\Subsubsection(Hybrid Jobs}


\Subsection{Zeus}

Zeus is a 



\Subsubsection{MPI Jobs}




\Subsubsection{OMP Jobs}



\Subsubsection{Helloworld}



\Subsubsection{Cuda Jobs}



\Subsubsection{Hybrid Jobs}


\Subsection{Zythos}



\Subsubsection{MPI Jobs}



\Subsubsection{OMP Jobs}



\Subsubsection{Helloworld}



\Subsubsection{Cuda Jobs}



\Subsubsection{Hybrid Jobs}


\Section{Other Completed Tasks}

\Subsection{Intel Xeon Processor}

\Subsection{MIC &MKL}


\Susection{Ubuntu}



\Subsection{Supercomputing Examples to Others}



\Section{Conclusion}




\Section{References}
\end{Document}
% end document
